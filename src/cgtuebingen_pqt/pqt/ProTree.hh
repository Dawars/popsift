#ifndef NEARESTNEIGHBOR_PROTREE_H
#define NEARESTNEIGHBOR_PROTREE_H

#include "ProQuantization.hh"
/*! \file  ProTree.hh
 \brief implements a two-layer tree of product quantization
 */

#define NUM_DISTSEQ 65536
#define NUM_NEIGHBORS 3

#define NUM_ANISO_DIR 10
#define ANISO_BASE 1.2f

namespace pqt {

inline __host__      __device__ uint getCBIdx(uint _p, uint _c, uint _nClusters,
		uint _vl, uint _nClusters2) {
	return (_p * _nClusters + _c) * _vl * _nClusters2;

}

inline __device__ uint calcIdxSequential(volatile uint *_idx, uint _p,
		uint _nClusters, uint _nClusters2, uint _c1scale) {

	uint idx = _idx[0];

	for (int k = 1; k < _p; k++) {
		idx = (idx * _nClusters * _nClusters2) + _idx[k];
	}

	return idx;

}

/** \class ProTree ProTree.hh
 implements a two-layer tree of product quantization */

class ProTree: public ProQuantization {

public:

	/** default constructor */
	ProTree(uint _dim, uint _p, uint _p2, uint _groupParts);
	ProTree(uint _dim, uint _p, uint _p2);

	~ProTree();

	/** prepares a sequence that traverses the _p-dimensional integer spaces according to distance to the origin, i.e. for _p == 3
	 *
	 *   000
	 *
	 *   001
	 *   010
	 *   100
	 *
	 *   002
	 *   011
	 *   020
	 *   110
	 *   200
	 *
	 *   003
	 *   ...
	 */
	void prepareDistSequence(int _dim, int _groupParts);

	/* only prepares 2D sequence as above. Multiple sequences are preapared for different potential slopes */
	void prepare2DDistSequence(int _dim);

	uint locateInSequence(uint _bins);

	std::vector<std::pair<uint, uint> >& getDistSeq() {
		return d_distSeqH;
	}

	/** produces a two-layer product quantization tree with _k basis vectors on each layer */
	void createTree(uint _k, uint _k2, const float* _A, uint _N);

	/** produces a two-layer product quantization tree with _k basis vectors on each layer given the trainings data _A
	 * After the first layer is build, the algorithm detects the Layer-1 bins that are most dense (contain the most elements).
	 * The creation of the Layer-2 codebook is constructed based only on vectors that
	 *     falls into the sparser bins: _sparse == true
	 *     falls into the denser bins:  _sparse == false
	 */
	void createTreeSplitSparse(uint _nClusters1, uint _nClusters2,
			const float* _A, uint _N, float _percent, bool _sparse);

	/** extract segment _p from all vectors of _A that are assigned to cluster _c in segment _p) */
	uint groupVectorSegments(float* _seg, const float* _A, uint _N, uint _p,
			uint _c, uint* _assign);

	/** same as above just considering the vectors that are marked sparse:
	 * _sparseVec[i] == _sparse.
	 */
	uint groupVectorSegmentsSparse(float* _seg, const float* _A, uint _N,
			uint _p, uint _c, uint* _assign, const uint *_sparseVec,
			bool _sparse);

	/** finds all neighbor cells */

	/** takes all vectors an _A and sorts their index into the corresponding leaf */
	void buildDB(const float* _A, uint _N);

	/** sort all _N vectors of _A into each DB of the individual groups */
	void buildMultiDB(const float* _A, uint _N);

	void fakeDB(const float* _A, uint _N);

	/** does the assignment of the second level */
	void getAssignment2(uint *_assign2, const float* _A, const float* _B,
			uint _Arows, uint _Brows, const uint *_assign1,
			uint _nClusters1) const;

	/** outputs the best bins */
	void getKBestAssignment2(float *_assignVal, uint *_assignIdx,
			const float* _A, const float* _B, uint _Arows, uint _Brows,
			const uint *_assign1, uint _nClusters1, uint _k1) const;

	/** produces as list of finals bin sorted by proximity to the query vector.
	 * It assembles the list of potential bins by an n-dimensional Dijkstra.
	 * assignVal and assignIdx are assumed to be generated by getKBestAssignment2
	 * _k1 is the number of bins visited on the first layer, _k2 the number of  vectors intended to be visited
	 * _maxBins is the maximum number of bins to be visited
	 * The output is the bin ids as well as how many bins have been selected for each of the _N query vectors
	 */
	void getBins(uint *_bins, uint *_nBins, const float *_assignVal,
			const uint *_assignIdx, uint _N, uint _k1, uint _k2, uint _maxBins);

	void getMultiBins(uint *_bins, uint *_nBins, const float *_assignVal,
			const uint *_assignIdx, uint _N, uint _k1, uint _k2, uint _maxBins,
			uint _groupParts, uint _nDBs);

	/** looks up all vectors in the proximity bins, computes the distance to the query vectors, sorts them and outputs the first _k
	 *
	 */
	void getKBestVectors(float *_bestDist, uint *_bestIdx, const uint *_bins,
			const uint *_nBins, uint _maxBins, const float* _Q, uint _QN,
			uint _k);

	/* new multi-DB structure */
	void getMultiKBestVectors(float *_bestDist, uint *_bestIdx,
			const uint *_bins, const uint *_nBins, uint _maxBins,
			const float* _Q, uint _QN, uint _k);

	/** looks for some nearest neighbors */
	void testKNN(const float* _Q, uint _QN);

	void testMultiKNN(const float* _Q, uint _QN);

	void testLevel1(const float* _Q, uint _QN);

	/** some initial testing */
	void testSort();
	void testScan();

	void writeTreeToFile(const std::string& _name);
	void readTreeFromFile(const std::string& _name);

//    void writeDBToFile( const std::string& _name );
//    void readDBFromFile( const std::string& _name );

	uint getGroupParts() const {
		return d_groupParts;
	}

	uint getClusters2() const {
		return d_nClusters2;
	}

	uint getNClusters() const {
		return d_nClusters;
	}

	float* getCodebook1() const {
		return d_codeBook;
	}

protected:

	void countBins(uint* _bins, const uint* _assign, uint* _assign2, uint _N);

	void countMultiBins(uint* _bins, const uint* _assign, const uint* _assign2,
			uint _N, uint _groupParts, uint _nDBs);

	void scan(uint *_prefixSum, const uint *_ptr, uint _n, bool _inclusive);

	void sortIdx(uint* _dbIdx, const uint* _assign, const uint* _assign2,
			uint _N);

	void sortMultiIdx(uint* _dbIdx, const uint* _assign, const uint* _assign2,
			uint _N, uint _groupParts, uint _nDBs);

	/** computes and outputs a histogram of the counted bins */
	void histogram(uint _nBins) const;

	/** computes the Histogram for bins formed by the coarse level codebook.
	 * The bins are sorted by their occupancy.
	 * The bins containing the densest _percent samples are marked as false in _sparseBin.
	 */
	void calcL1Histogram(uint* _sparseBin, const uint* assignd, uint _N,
			float _percent);

	/** given the marked sparse bins, all vectors that are in the sparse / dense bins are marked
	 * _sparse == false - mark vectors in dense areas as true
	 * _sparse == true  - mark vectors in sparse areas as true
	 */
	void markSparseVectors(uint* _sparseVec, const uint* _sparseBin,
			const uint* assignd, uint _N, bool _sparse) const;

	uint d_nClusters2; // cluster center on the second level

	uint d_groupParts;  // number of parts creating one group
	uint d_nDBs; 		// number of resulting databases

	uint d_p2; // number of parts on second level (should be the same as d_p
	uint d_vl2;

	uint d_nBins;  // number of leafs in final tree

	// living the the GPU
	uint* d_count;
	float* d_codeBook2;

	uint d_NdbVec;   // number of total vectors in data base
	const float* d_dbVec; // pointer to the original vectors in the data base (will not be freed when calling the destructor)

	uint* d_binPrefix;
	uint* d_binCounts;
	uint* d_dbIdx;

	uint* d_distSeq; // array storing the traversal order for the k nearest clusters

	uint d_numDistSeq; // number of reasonable vectors in distance sequence
	uint d_distCluster; // number of clusters to be visited in each part

	uint* d_sparseBin; // array on device storing the indicator array for the first level bins

	std::vector<std::pair<uint, uint> > d_distSeqH;
}
;

} /* namespace */

#endif /* NEARESTNEIGHBOR_PROTREE_H */
